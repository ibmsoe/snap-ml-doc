
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>linear_model.LogisticRegression &#8212; Snap Machine Learning 1.0 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>

<div style="background-color: white; text-align: left; padding: 10px 10px 15px 15px">
<a href="index.html"><h1 style="font-size: 3em;">Snap Machine Learning</h1></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="linear-model-logisticregression">
<span id="sk-logreg-doc"></span><h1>linear_model.LogisticRegression<a class="headerlink" href="#linear-model-logisticregression" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pai4sk.linear_model.LogisticRegression">
<em class="property">class </em><code class="descclassname">pai4sk.linear_model.</code><code class="descname">LogisticRegression</code><span class="sig-paren">(</span><em>penalty='l2'</em>, <em>dual=False</em>, <em>tol=0.0001</em>, <em>C=1.0</em>, <em>fit_intercept=True</em>, <em>intercept_scaling=1</em>, <em>class_weight=None</em>, <em>random_state=None</em>, <em>solver='warn'</em>, <em>max_iter=100</em>, <em>multi_class='warn'</em>, <em>verbose=0</em>, <em>warm_start=False</em>, <em>n_jobs=None</em>, <em>use_gpu=True</em>, <em>device_ids=[]</em>, <em>return_training_history=None</em>, <em>privacy=False</em>, <em>eta=0.3</em>, <em>batch_size=100</em>, <em>privacy_epsilon=10</em>, <em>grad_clip=1</em>, <em>num_threads=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pai4sk.linear_model.LogisticRegression" title="Permalink to this definition">¶</a></dt>
<dd><p>Logistic Regression (aka logit, MaxEnt) classifier.</p>
<p>In the multiclass case, the training algorithm uses the one-vs-rest (OvR)
scheme if the ‘multi_class’ option is set to ‘ovr’, and uses the cross-
entropy loss if the ‘multi_class’ option is set to ‘multinomial’.
(Currently the ‘multinomial’ option is supported only by the ‘lbfgs’,
‘sag’ and ‘newton-cg’ solvers.)</p>
<p>This class implements regularized logistic regression using the
‘liblinear’ library, ‘newton-cg’, ‘sag’ and ‘lbfgs’ solvers. It can handle
both dense and sparse input. Use C-ordered arrays or CSR matrices
containing 64-bit floats for optimal performance; any other input format
will be converted (and copied).</p>
<p>The ‘newton-cg’, ‘sag’, and ‘lbfgs’ solvers support only L2 regularization
with primal formulation. The ‘liblinear’ solver supports both L1 and L2
regularization, with a dual formulation only for the L2 penalty.</p>
<p>Read more in the <span class="xref std std-ref">User Guide</span>.</p>
<p>For SnapML solver this supports both local and distributed(MPI) method of execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>penalty</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><em>'l1'</em><em> or </em><em>'l2'</em><em>, </em><em>default: 'l2'</em>) – <p>Used to specify the norm used in the penalization. The ‘newton-cg’,
‘sag’ and ‘lbfgs’ solvers support only l2 penalties.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.19: </span>l1 penalty with SAGA solver (allowing ‘multinomial’ + L1)</p>
</div>
</li>
<li><strong>dual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default: False</em>) – Dual or primal formulation. Dual formulation is only implemented for
l2 penalty with liblinear solver. Prefer dual=False when
n_samples &gt; n_features.</li>
<li><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default: 1e-4</em>) – Tolerance for stopping criteria.</li>
<li><strong>C</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default: 1.0</em>) – Inverse of regularization strength; must be a positive float.
Like in support vector machines, smaller values specify stronger
regularization.</li>
<li><strong>fit_intercept</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default: True</em>) – Specifies if a constant (a.k.a. bias or intercept) should be
added to the decision function.</li>
<li><strong>intercept_scaling</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default 1.</em>) – <p>Useful only when the solver ‘liblinear’ is used
and self.fit_intercept is set to True. In this case, x becomes
[x, self.intercept_scaling],
i.e. a “synthetic” feature with constant value equal to
intercept_scaling is appended to the instance vector.
The intercept becomes <code class="docutils literal notranslate"><span class="pre">intercept_scaling</span> <span class="pre">*</span> <span class="pre">synthetic_feature_weight</span></code>.</p>
<p>Note! the synthetic feature weight is subject to l1/l2 regularization
as all other features.
To lessen the effect of regularization on synthetic feature weight
(and therefore on the intercept) intercept_scaling has to be increased.</p>
</li>
<li><strong>class_weight</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a><em> or </em><em>'balanced'</em><em>, </em><em>default: None</em>) – <p>Weights associated with classes in the form <code class="docutils literal notranslate"><span class="pre">{class_label:</span> <span class="pre">weight}</span></code>.
If not given, all classes are supposed to have weight one.</p>
<p>The “balanced” mode uses the values of y to automatically adjust
weights inversely proportional to class frequencies in the input data
as <code class="docutils literal notranslate"><span class="pre">n_samples</span> <span class="pre">/</span> <span class="pre">(n_classes</span> <span class="pre">*</span> <span class="pre">np.bincount(y))</span></code>.</p>
<p>Note that these weights will be multiplied with sample_weight (passed
through the fit method) if sample_weight is specified.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>class_weight=’balanced’</em></p>
</div>
</li>
<li><strong>random_state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>RandomState instance</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em>, </em><em>default: None</em>) – The seed of the pseudo random number generator to use when shuffling
the data.  If int, random_state is the seed used by the random number
generator; If RandomState instance, random_state is the random number
generator; If None, the random number generator is the RandomState
instance used by <cite>np.random</cite>. Used when <code class="docutils literal notranslate"><span class="pre">solver</span></code> == ‘sag’ or
‘liblinear’.</li>
<li><strong>solver</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><em>{'newton-cg'</em><em>, </em><em>'lbfgs'</em><em>, </em><em>'liblinear'</em><em>, </em><em>'sag'</em><em>, </em><em>'saga'</em><em>, </em><em>'snapml'}</em><em>,              </em><em>default: 'snapml'</em><em>, </em><em>if 'snap_ml' library is in PYTHONPATH</em><em>, </em><em>else</em><em>,</em>) – <p>default: ‘liblinear’.</p>
<p>Algorithm to use in the optimization problem.</p>
<ul>
<li>For small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and
‘saga’ are faster for large ones.</li>
<li>For multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’
handle multinomial loss; ‘liblinear’ is limited to one-versus-rest
schemes.</li>
<li>’newton-cg’, ‘lbfgs’ and ‘sag’ only handle L2 penalty, whereas
‘liblinear’ and ‘saga’ handle L1 penalty.</li>
</ul>
<p>Note that ‘sag’ and ‘saga’ fast convergence is only guaranteed on
features with approximately the same scale. You can
preprocess the data with a scaler from pai4sk.preprocessing.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17: </span>Stochastic Average Gradient descent solver.</p>
</div>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.19: </span>SAGA solver.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.20: </span>Default will change from ‘liblinear’ to ‘lbfgs’ in 0.22.</p>
</div>
</li>
<li><strong>max_iter</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default: 100</em>) – Useful only for the newton-cg, sag and lbfgs solvers.
Maximum number of iterations taken for the solvers to converge.</li>
<li><strong>multi_class</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>, </em><em>{'ovr'</em><em>, </em><em>'multinomial'</em><em>, </em><em>'auto'}</em><em>, </em><em>default: 'ovr'</em>) – <p>If the option chosen is ‘ovr’, then a binary problem is fit for each
label. For ‘multinomial’ the loss minimised is the multinomial loss fit
across the entire probability distribution, <em>even when the data is
binary</em>. ‘multinomial’ is unavailable when solver=’liblinear’.
‘auto’ selects ‘ovr’ if the data is binary, or if solver=’liblinear’,
and otherwise selects ‘multinomial’.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.18: </span>Stochastic Average Gradient descent solver for ‘multinomial’ case.</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.20: </span>Default will change from ‘ovr’ to ‘auto’ in 0.22.</p>
</div>
</li>
<li><strong>verbose</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default: 0</em>) – For the liblinear and lbfgs solvers set verbose to any positive
number for verbosity.</li>
<li><strong>warm_start</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default: False</em>) – <p>When set to True, reuse the solution of the previous call to fit as
initialization, otherwise, just erase the previous solution.
Useless for liblinear solver. See <span class="xref std std-term">the Glossary</span>.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 0.17: </span><em>warm_start</em> to support <em>lbfgs</em>, <em>newton-cg</em>, <em>sag</em>, <em>saga</em> solvers.</p>
</div>
</li>
<li><strong>n_jobs</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>optional</em><em> (</em><em>default=None</em><em>)</em>) – Number of CPU cores used when parallelizing over classes if
multi_class=’ovr’”. This parameter is ignored when the <code class="docutils literal notranslate"><span class="pre">solver</span></code> is
set to ‘liblinear’ regardless of whether ‘multi_class’ is specified or
not. <code class="docutils literal notranslate"><span class="pre">None</span></code> means 1 unless in a <code class="xref py py-obj docutils literal notranslate"><span class="pre">joblib.parallel_backend</span></code>
context. <code class="docutils literal notranslate"><span class="pre">-1</span></code> means using all processors.
See <span class="xref std std-term">Glossary</span> for more details.</li>
<li><strong>use_gpu</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default : False</em>) – Flag for indicating the hardware platform used for training. If True, the training
is performed using the GPU. If False, the training is performed using the CPU.
Applicable only for snapml solver</li>
<li><strong>device_ids</strong> (<em>array-like of int</em><em>, </em><em>default :</em><em> [</em><em>]</em>) – If use_gpu is True, it indicates the IDs of the GPUs used for training.
For single-GPU training, set device_ids to the GPU ID to be used for training, e.g., [0].
For multi-GPU training, set device_ids to a list of GPU IDs to be used for training, e.g., [0, 1].
Applicable only for snapml solver</li>
<li><strong>num_threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default : 1</em>) – The number of threads used for running the training. The value of this parameter
should be a multiple of 32 if the training is performed on GPU (use_gpu=True)
(default value for GPU is 256). Applicable only for snapml solver</li>
<li><strong>return_training_history</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.7)"><em>None</em></a><em>, </em><em>default : None</em>) – How much information about the training should be collected and returned by the fit function. By
default no information is returned (None), but this parameter can be set to “summary”, to obtain
summary statistics at the end of training, or “full” to obtain a complete set of statistics
for the entire training procedure. Note, enabling either option will result in slower training.
Applicable only for snapml solver</li>
<li><strong>privacy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>, </em><em>default : False</em>) – Train the model using a differentially private algorithm.</li>
<li><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default : 0.3</em>) – Learning rate for the differentially private training algorithm.</li>
<li><strong>batch_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default : 100</em>) – Mini-batch size for the differentially private training algorithm.</li>
<li><strong>privacy_epsilon</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default : 10.0</em>) – Target privacy gaurantee. Learned model will be (privacy_epsilon, 0.01)-private.</li>
<li><strong>grad_clip</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>, </em><em>default: 1.0</em>) – Gradient clipping parameter for the differentially private training algorithm</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>coef</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>, </em><em>n_features</em><em>) or </em><em>(</em><em>n_classes</em><em>, </em><em>n_features</em><em>)</em>) – <p>Coefficient of the features in the decision function.</p>
<p><cite>coef_</cite> is of shape (1, n_features) when the given problem is binary.
In particular, when <cite>multi_class=’multinomial’</cite>, <cite>coef_</cite> corresponds
to outcome 1 (True) and <cite>-coef_</cite> corresponds to outcome 0 (False).</p>
</li>
<li><strong>intercept</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>1</em><em>,</em><em>) or </em><em>(</em><em>n_classes</em><em>,</em><em>)</em>) – <p>Intercept (a.k.a. bias) added to the decision function.</p>
<p>If <cite>fit_intercept</cite> is set to False, the intercept is set to zero.
<cite>intercept_</cite> is of shape (1,) when the given problem is binary.
In particular, when <cite>multi_class=’multinomial’</cite>, <cite>intercept_</cite>
corresponds to outcome 1 (True) and <cite>-intercept_</cite> corresponds to
outcome 0 (False).</p>
</li>
<li><strong>n_iter</strong> (<em>array</em><em>, </em><em>shape</em><em> (</em><em>n_classes</em><em>,</em><em>) or </em><em>(</em><em>1</em><em>, </em><em>)</em>) – Actual number of iterations for all classes. If binary or multinomial,
it returns only 1 element. For liblinear solver, only the maximum
number of iteration across all classes is given.</li>
<li><strong>training_history</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – It returns a dictionary with the following keys : ‘epochs’, ‘t_elap_sec’, ‘train_obj’.
If ‘return_training_history’ is set to “summary”, ‘epochs’ contains the total number of
epochs performed, ‘t_elap_sec’ contains the total time for completing all of those epochs.
If ‘return_training_history’ is set to “full”, ‘epochs’ indicates the number of epochs
that have elapsed so far, and ‘t_elap_sec’ contains the time to do those epochs.
‘train_obj’ is the training loss.
Applicable only for snapml solver.</li>
<li><strong>support</strong> (<em>array-like</em>) – Indices of the features that contribute to the decision. (only available for L1)</li>
<li><strong>model_sparsity</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – <p>Fraction of non-zeros in the model parameters. (only available for L1)</p>
<div class="versionchanged">
<p><span class="versionmodified">Changed in version 0.20: </span>In SciPy &lt;= 1.0.0 the number of lbfgs iterations may exceed
<code class="docutils literal notranslate"><span class="pre">max_iter</span></code>. <code class="docutils literal notranslate"><span class="pre">n_iter_</span></code> will now report at most <code class="docutils literal notranslate"><span class="pre">max_iter</span></code>.</p>
</div>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pai4sk.datasets</span> <span class="k">import</span> <span class="n">load_iris</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pai4sk.linear_model</span> <span class="k">import</span> <span class="n">LogisticRegression</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">load_iris</span><span class="p">(</span><span class="n">return_X_y</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">multi_class</span><span class="o">=</span><span class="s1">&#39;multinomial&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span>
<span class="go">array([0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:])</span> <span class="c1"># doctest: +ELLIPSIS</span>
<span class="go">array([[9.8...e-01, 1.8...e-02, 1.4...e-08],</span>
<span class="go">       [9.7...e-01, 2.8...e-02, ...e-08]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clf</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">0.97...</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">SGDClassifier</span></code></dt>
<dd>incrementally trained logistic regression (when given the parameter <code class="docutils literal notranslate"><span class="pre">loss=&quot;log&quot;</span></code>).</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">LogisticRegressionCV</span></code></dt>
<dd>Logistic regression with built-in cross validation</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The underlying C implementation uses a random number generator to
select features when fitting the model. It is thus not uncommon,
to have slightly different results for the same input data. If
that happens, try with a smaller tol parameter.</p>
<p>Predict output may not match that of standalone liblinear in certain
cases. See <span class="xref std std-ref">differences from liblinear</span>
in the narrative documentation.</p>
<p class="rubric">References</p>
<dl class="docutils">
<dt>LIBLINEAR – A Library for Large Linear Classification</dt>
<dd><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/liblinear/">http://www.csie.ntu.edu.tw/~cjlin/liblinear/</a></dd>
<dt>SAG – Mark Schmidt, Nicolas Le Roux, and Francis Bach</dt>
<dd>Minimizing Finite Sums with the Stochastic Average Gradient
<a class="reference external" href="https://hal.inria.fr/hal-00860051/document">https://hal.inria.fr/hal-00860051/document</a></dd>
<dt>SAGA – Defazio, A., Bach F. &amp; Lacoste-Julien S. (2014).</dt>
<dd>SAGA: A Fast Incremental Gradient Method With Support
for Non-Strongly Convex Composite Objectives
<a class="reference external" href="https://arxiv.org/abs/1407.0202">https://arxiv.org/abs/1407.0202</a></dd>
<dt>Hsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent</dt>
<dd>methods for logistic regression and maximum entropy models.
Machine Learning 85(1-2):41-75.
<a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf">http://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf</a></dd>
</dl>
<dl class="method">
<dt id="pai4sk.linear_model.LogisticRegression.fit">
<code class="descname">fit</code><span class="sig-paren">(</span><em>X</em>, <em>y</em>, <em>sample_weight=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pai4sk.linear_model.LogisticRegression.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit the model according to the given training data.
:param X: Training vector, where n_samples is the number of samples and</p>
<blockquote>
<div>n_features is the number of features.
For SnapML solver it also supports input of types SnapML data partition and DeviceNDArray.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>y</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>) or </em><em>(</em><em>n_samples</em><em>, </em><em>n_targets</em><em>)</em>) – Target vector relative to X.</li>
<li><strong>sample_weight</strong> (<em>array-like</em><em>, </em><em>shape</em><em> (</em><em>n_samples</em><em>,</em><em>) </em><em>optional</em>) – <p>Array of weights that are assigned to individual samples.
If not provided, then each sample is given unit weight.
.. versionadded:: 0.17</p>
<blockquote>
<div><em>sample_weight</em> support to LogisticRegression.</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>self</strong></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.7)">object</a></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pai4sk.linear_model.LogisticRegression.predict">
<code class="descname">predict</code><span class="sig-paren">(</span><em>X</em>, <em>num_threads=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pai4sk.linear_model.LogisticRegression.predict" title="Permalink to this definition">¶</a></dt>
<dd><p>Class predictions
The returned class estimates.
:param X: Dataset used for predicting class estimates.</p>
<blockquote>
<div>For SnapML solver it also supports input of type SnapML data partition.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num_threads</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>, </em><em>default : 0</em>) – Number of threads used to run inference.
By default inference runs with maximum number of available threads.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>proba</strong> – Returns the predicted class of the sample.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">array-like, shape = (n_samples,)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pai4sk.linear_model.LogisticRegression.predict_log_proba">
<code class="descname">predict_log_proba</code><span class="sig-paren">(</span><em>X</em><span class="sig-paren">)</span><a class="headerlink" href="#pai4sk.linear_model.LogisticRegression.predict_log_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Log of probability estimates.
The returned estimates for all classes are ordered by the
label of classes.
:param X: For SnapML solver it also supports input of type SnapML data partition.
:type X: array-like, shape = [n_samples, n_features]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>T</strong> – Returns the log-probability of the sample for each class in the
model, where classes are ordered as they are in <code class="docutils literal notranslate"><span class="pre">self.classes_</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">array-like, shape = [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pai4sk.linear_model.LogisticRegression.predict_proba">
<code class="descname">predict_proba</code><span class="sig-paren">(</span><em>X</em>, <em>num_threads=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pai4sk.linear_model.LogisticRegression.predict_proba" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability estimates.
The returned estimates for all classes are ordered by the
label of classes.
For a multi_class problem, if multi_class is set to be “multinomial”
the softmax function is used to find the predicted probability of
each class.
Else use a one-vs-rest approach, i.e calculate the probability
of each class assuming it to be positive using the logistic function.
and normalize these values across all the classes.
:param X: For SnapML solver it also supports input of type SnapML data partition.
:type X: array-like, shape = [n_samples, n_features]
:param num_threads: Number of threads used to run inference.</p>
<blockquote>
<div>By default inference runs with maximum number of available threads.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>T</strong> – Returns the probability of the sample for each class in the model,
where classes are ordered as they are in <code class="docutils literal notranslate"><span class="pre">self.classes_</span></code>.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">array-like, shape = [n_samples, n_classes]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">home</a>|&nbsp;</li>
        <li><a href="search.html">search</a>|&nbsp;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, cdu.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.2.
    </div>
  </body>
</html>